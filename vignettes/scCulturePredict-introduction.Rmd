---
title: "Introduction to scCulturePredict"
author: "NiccolÃ² Bianchi"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Introduction to scCulturePredict}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  fig.width = 7,
  fig.height = 5
)
```

# Introduction

The `scCulturePredict` package provides a comprehensive pipeline for analyzing single-cell RNA sequencing data from yeast culture experiments. It enables researchers to:

- Identify cell culture conditions from transcriptomic profiles
- Build predictive models using pathway fingerprints
- Analyze pathway activity patterns across different conditions
- Support both 10X Genomics and SingleCellExperiment data formats

This vignette provides an introduction to the main functionality of the package.

# Installation

The `scCulturePredict` package is available on Bioconductor and can be installed using:

```{r install, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("scCulturePredict")
```

# Getting Started

```{r setup_packages}
library(scCulturePredict)
library(Seurat)
library(SingleCellExperiment)
library(ggplot2)
set.seed(123)  # For reproducibility
```

# Working with Example Data

## Creating Mock Data for Demonstration

For this vignette, we'll create simple mock data to demonstrate the package functionality:

```{r create_mock_data}
# Create simple mock Seurat object
create_simple_seurat <- function(n_genes = 200, n_cells = 100) {
  # Create count matrix
  counts <- matrix(rpois(n_genes * n_cells, lambda = 5),
                   nrow = n_genes, ncol = n_cells)

  # Use simple gene names to avoid duplicates
  rownames(counts) <- paste0("Gene", seq_len(n_genes))
  colnames(counts) <- paste0("Cell", seq_len(n_cells))

  # Create metadata
  metadata <- data.frame(
    sample = rep(c("DMSO", "Guanine", "Adenine", "Thymine"),
                 length.out = n_cells),
    batch = rep(c("Batch1", "Batch2"), each = n_cells/2),
    row.names = colnames(counts)
  )

  # Create Seurat object
  seurat_obj <- CreateSeuratObject(
    counts = counts,
    meta.data = metadata,
    min.cells = 3,
    min.features = 10
  )

  return(seurat_obj)
}

# Create our mock data
seurat_data <- create_simple_seurat(n_genes = 200, n_cells = 100)
print(seurat_data)
```

# Core Functions

## Data Preprocessing

The `preprocess_data` function normalizes and scales the data:

```{r preprocess}
# Preprocess the data
seurat_processed <- preprocess_data(
  seurat_obj = seurat_data,
  n_features = 100,
  verbose = TRUE
)

print(paste("Number of variable features:",
            length(VariableFeatures(seurat_processed))))
```

## Dimensionality Reduction

The `reduce_dimensions` function performs PCA and UMAP:

```{r dimred}
# First run PCA (required for UMAP)
seurat_processed <- RunPCA(seurat_processed,
                           features = VariableFeatures(seurat_processed),
                           npcs = 20,
                           verbose = FALSE)

# Perform dimensionality reduction
seurat_reduced <- reduce_dimensions(
  seurat_object = seurat_processed,
  perform_tsne = FALSE,
  verbose = TRUE
)

# Check that UMAP coordinates were added
if(all(c("UMAP_1", "UMAP_2") %in% colnames(seurat_reduced@meta.data))) {
  print("UMAP coordinates successfully added")
} else {
  # If not added by reduce_dimensions, compute manually
  seurat_reduced <- RunUMAP(seurat_reduced, dims = 1:10, verbose = FALSE)
  seurat_reduced@meta.data$UMAP_1 <- Embeddings(seurat_reduced, "umap")[, 1]
  seurat_reduced@meta.data$UMAP_2 <- Embeddings(seurat_reduced, "umap")[, 2]
}
```

## Visualization

```{r visualization, fig.width=8, fig.height=6}
# Visualize UMAP
if(all(c("UMAP_1", "UMAP_2") %in% colnames(seurat_reduced@meta.data))) {
  p <- ggplot(seurat_reduced@meta.data,
              aes(x = UMAP_1, y = UMAP_2, color = sample)) +
    geom_point(size = 2, alpha = 0.7) +
    theme_minimal() +
    labs(title = "UMAP of Mock Single-Cell Data",
         x = "UMAP 1", y = "UMAP 2",
         color = "Condition") +
    scale_color_brewer(palette = "Set1")

  print(p)
}
```

## Pathway Analysis

For pathway analysis, we can create mock pathway data:

```{r pathway_analysis}
# Create mock KEGG pathways
mock_pathways <- list(
  Glycolysis = paste0("Gene", 1:20),
  TCA_Cycle = paste0("Gene", 21:40),
  Oxidative_Phosphorylation = paste0("Gene", 41:60),
  Amino_Acid_Metabolism = paste0("Gene", 61:80),
  Lipid_Metabolism = paste0("Gene", 81:100)
)

# Build pathway fingerprints
pathway_matrix <- build_fingerprints(
  seurat_object = seurat_reduced,
  kegg_pathways = mock_pathways,
  verbose = TRUE
)

# Check the results
if (!is.null(pathway_matrix)) {
  print(paste("Pathway matrix dimensions:",
              nrow(pathway_matrix$pathway_matrix), "cells x",
              ncol(pathway_matrix$pathway_matrix), "pathways"))

  # Show first few entries
  if (ncol(pathway_matrix$pathway_matrix) >= 3) {
    print(head(pathway_matrix$pathway_matrix[, 1:3], n = 3))
  } else {
    print(head(pathway_matrix$pathway_matrix, n = 3))
  }
}
```

## Prediction

We can demonstrate the prediction functions:

```{r prediction}
# Use pathway matrix for predictions if available
if (!is.null(pathway_matrix) && nrow(pathway_matrix$pathway_matrix) > 20) {
  # Make predictions using SVM
  svm_results <- predict_by_svm(
    pathway_matrix = pathway_matrix$pathway_matrix,
    seurat_object = seurat_reduced,
    verbose = TRUE
  )

  # Check results
  if (!is.null(svm_results$predictions)) {
    seurat_reduced$predicted_sample <- svm_results$predictions

    # Calculate accuracy
    actual <- seurat_reduced$sample
    predicted <- seurat_reduced$predicted_sample
    accuracy <- sum(actual == predicted) / length(actual)

    print(paste("Prediction accuracy:", round(accuracy * 100, 2), "%"))

    # Show confusion matrix
    print("Confusion Matrix:")
    print(table(Actual = actual, Predicted = predicted))
  }
}
```

## Evaluation

Evaluate the prediction results:

```{r evaluation}
# Evaluate predictions if they exist
if ("predicted_sample" %in% colnames(seurat_reduced@meta.data)) {
  # Calculate evaluation metrics
  actual <- seurat_reduced$sample
  predicted <- seurat_reduced$predicted_sample

  # Overall accuracy
  overall_acc <- sum(actual == predicted, na.rm = TRUE) / length(actual)

  # Per-class accuracy
  classes <- unique(actual)
  class_acc <- sapply(classes, function(cls) {
    idx <- actual == cls
    sum(actual[idx] == predicted[idx], na.rm = TRUE) / sum(idx)
  })

  # Display results
  print("Evaluation Results:")
  print(paste("Overall accuracy:", round(overall_acc * 100, 2), "%"))

  print("Per-class accuracy:")
  acc_df <- data.frame(
    Class = classes,
    Accuracy = round(class_acc * 100, 2)
  )
  print(acc_df)
}
```

# Working with Different Data Formats

## SingleCellExperiment Format

The package also supports SingleCellExperiment objects:

```{r sce_format}
# Convert to SingleCellExperiment
sce_data <- as.SingleCellExperiment(seurat_reduced)
print(sce_data)

# The package functions work with both formats
# For loading SCE data from file, you would use:
# sce_data <- load_sce_data("path/to/sce.rds")
```

# Complete Pipeline with scCulture

For a complete analysis pipeline, the `scCulture` function combines all steps:

```{r scculture_example, eval=FALSE}
# Example of using scCulture with real data
# This example is not evaluated as it requires actual data files

# For 10X Genomics data:
results <- scCulture(
  mode = "build",
  tenx_data_dir = "path/to/10x/data",
  input_type = "10x",
  experiment_id = "my_experiment",
  output_dir = "./results",
  verbose = TRUE
)

# For SingleCellExperiment data:
results <- scCulture(
  mode = "build",
  sce_data_path = "path/to/sce.rds",
  input_type = "sce",
  experiment_id = "my_experiment",
  output_dir = "./results",
  verbose = TRUE
)

# Access results
seurat_object <- results$seurat_object
pathway_results <- results$pathway_results
prediction_results <- results$prediction_results
```

# Tips for Using scCulturePredict

1. **Data Requirements**: Ensure your data has sufficient cells (>50) and genes (>100) for reliable analysis.

2. **KEGG Pathways**: The package includes example KEGG pathway data. For real analysis, use organism-specific pathway databases.

3. **Parameter Tuning**: Adjust parameters like `n_features` in preprocessing and `train_ratio` in prediction based on your dataset size.

4. **Cross-validation**: For robust results, consider using cross-validation when building predictive models.

# Session Information

```{r session_info}
sessionInfo()
```
