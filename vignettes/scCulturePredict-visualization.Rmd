---
title: "Visualization with scCulturePredict"
author: "NiccolÃ² Bianchi"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Visualization with scCulturePredict}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 6
)
```

# Introduction

This vignette demonstrates visualization capabilities of the `scCulturePredict` package for exploring single-cell RNA-seq data and prediction results.

# Setup

```{r setup_packages}
library(scCulturePredict)
library(Seurat)
library(ggplot2)
library(dplyr)
set.seed(123)  # For reproducibility
```

# Creating Example Data

```{r create_data}
# Create simple mock data for visualization
create_viz_data <- function(n_genes = 200, n_cells = 150) {
  # Create count matrix
  counts <- matrix(rpois(n_genes * n_cells, lambda = 5),
                   nrow = n_genes, ncol = n_cells)

  # Simple gene and cell names
  rownames(counts) <- paste0("Gene", seq_len(n_genes))
  colnames(counts) <- paste0("Cell", seq_len(n_cells))

  # Create metadata with multiple variables
  metadata <- data.frame(
    condition = rep(c("Control", "Treatment_A", "Treatment_B"), each = n_cells/3),
    batch = rep(c("Batch1", "Batch2"), length.out = n_cells),
    n_genes = colSums(counts > 0),
    n_counts = colSums(counts),
    percent_mt = runif(n_cells, 0, 20),
    row.names = colnames(counts)
  )

  # Create Seurat object
  seurat_obj <- CreateSeuratObject(
    counts = counts,
    meta.data = metadata,
    min.cells = 3,
    min.features = 10
  )

  # Process the data
  seurat_obj <- NormalizeData(seurat_obj, verbose = FALSE)
  seurat_obj <- FindVariableFeatures(seurat_obj, nfeatures = 100, verbose = FALSE)
  seurat_obj <- ScaleData(seurat_obj, verbose = FALSE)
  seurat_obj <- RunPCA(seurat_obj, npcs = 20, verbose = FALSE)
  seurat_obj <- RunUMAP(seurat_obj, dims = 1:10, verbose = FALSE)

  # Add UMAP coordinates to metadata
  seurat_obj@meta.data$UMAP_1 <- Embeddings(seurat_obj, "umap")[, 1]
  seurat_obj@meta.data$UMAP_2 <- Embeddings(seurat_obj, "umap")[, 2]

  # Add mock predictions
  seurat_obj@meta.data$predicted_condition <- sample(
    c("Control", "Treatment_A", "Treatment_B"),
    n_cells, replace = TRUE
  )
  seurat_obj@meta.data$prediction_confidence <- runif(n_cells, 0.5, 1.0)

  return(seurat_obj)
}

# Create the data
viz_data <- create_viz_data(n_genes = 200, n_cells = 150)
print(viz_data)
```

# Quality Control Visualizations

## QC Metrics Distribution

```{r qc_plots, fig.width=10, fig.height=8}
# Extract metadata for plotting
meta_data <- viz_data@meta.data

# Create QC visualization
p1 <- ggplot(meta_data, aes(x = condition, y = n_genes, fill = condition)) +
  geom_violin(alpha = 0.7) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "Genes per Cell by Condition",
       x = "Condition", y = "Number of Genes") +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "none")

p2 <- ggplot(meta_data, aes(x = condition, y = percent_mt, fill = condition)) +
  geom_violin(alpha = 0.7) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "Mitochondrial % by Condition",
       x = "Condition", y = "MT %") +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "none")

p3 <- ggplot(meta_data, aes(x = n_counts, y = n_genes, color = percent_mt)) +
  geom_point(alpha = 0.6, size = 2) +
  theme_minimal() +
  labs(title = "Count-Gene Relationship",
       x = "Total Counts", y = "Total Genes",
       color = "MT %") +
  scale_color_gradient(low = "blue", high = "red")

p4 <- ggplot(meta_data, aes(x = batch, fill = condition)) +
  geom_bar(position = "dodge") +
  theme_minimal() +
  labs(title = "Cell Distribution across Batches",
       x = "Batch", y = "Count") +
  scale_fill_brewer(palette = "Set1")

# Combine plots using base R graphics
par(mfrow = c(2, 2))
# Note: For actual combination, use patchwork or gridExtra packages
# Here we'll display them individually
print(p1)
print(p2)
print(p3)
print(p4)
par(mfrow = c(1, 1))
```

# Dimensionality Reduction Visualizations

## UMAP Visualization

```{r umap_plots, fig.width=10, fig.height=8}
# UMAP colored by condition
p_condition <- ggplot(meta_data, aes(x = UMAP_1, y = UMAP_2, color = condition)) +
  geom_point(size = 2, alpha = 0.7) +
  theme_minimal() +
  labs(title = "UMAP by Condition",
       x = "UMAP 1", y = "UMAP 2") +
  scale_color_brewer(palette = "Set1")

print(p_condition)

# UMAP colored by batch
p_batch <- ggplot(meta_data, aes(x = UMAP_1, y = UMAP_2, color = batch)) +
  geom_point(size = 2, alpha = 0.7) +
  theme_minimal() +
  labs(title = "UMAP by Batch",
       x = "UMAP 1", y = "UMAP 2") +
  scale_color_brewer(palette = "Dark2")

print(p_batch)

# UMAP colored by gene count
p_genes <- ggplot(meta_data, aes(x = UMAP_1, y = UMAP_2, color = n_genes)) +
  geom_point(size = 2, alpha = 0.7) +
  theme_minimal() +
  labs(title = "UMAP by Gene Count",
       x = "UMAP 1", y = "UMAP 2",
       color = "Genes") +
  scale_color_gradient(low = "darkblue", high = "yellow")

print(p_genes)
```

## PCA Visualization

```{r pca_plots}
# Get PCA coordinates
pca_coords <- Embeddings(viz_data, "pca")[, 1:4]
meta_data$PC1 <- pca_coords[, 1]
meta_data$PC2 <- pca_coords[, 2]

# PCA plot
p_pca <- ggplot(meta_data, aes(x = PC1, y = PC2, color = condition)) +
  geom_point(size = 2, alpha = 0.7) +
  theme_minimal() +
  labs(title = "PCA: PC1 vs PC2",
       color = "Condition") +
  scale_color_brewer(palette = "Set1")

print(p_pca)

# Variance explained
pca_var <- Stdev(viz_data, reduction = "pca")^2
var_explained <- pca_var / sum(pca_var) * 100

var_df <- data.frame(
  PC = 1:min(20, length(var_explained)),
  Variance = var_explained[1:min(20, length(var_explained))]
)

p_var <- ggplot(var_df, aes(x = PC, y = Variance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_line(color = "red") +
  theme_minimal() +
  labs(title = "PCA Variance Explained",
       x = "Principal Component",
       y = "Variance Explained (%)")

print(p_var)
```

# Pathway Analysis Visualization

```{r pathway_viz}
# Create mock pathway activity data
n_pathways <- 10
pathway_names <- c("Glycolysis", "TCA_Cycle", "Cell_Cycle", "DNA_Repair",
                   "Translation", "Oxidative_Stress", "Metabolism",
                   "Signaling", "Transport", "Biosynthesis")

# Create mock pathway matrix
pathway_matrix <- matrix(rnorm(ncol(viz_data) * n_pathways),
                        nrow = ncol(viz_data),
                        ncol = n_pathways)
colnames(pathway_matrix) <- pathway_names[1:n_pathways]
rownames(pathway_matrix) <- colnames(viz_data)

# Calculate mean pathway activity by condition
pathway_summary <- data.frame(
  pathway_matrix,
  condition = viz_data$condition
) %>%
  group_by(condition) %>%
  summarise(across(everything(), mean))

# Reshape for plotting
pathway_long <- tidyr::pivot_longer(pathway_summary,
                                   cols = -condition,
                                   names_to = "Pathway",
                                   values_to = "Activity")

# Create heatmap-style plot with ggplot2
p_pathway <- ggplot(pathway_long, aes(x = Pathway, y = condition, fill = Activity)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Mean Pathway Activity by Condition",
       x = "Pathway", y = "Condition")

print(p_pathway)
```

# Prediction Visualization

## Confusion Matrix

```{r confusion_matrix}
# Create confusion matrix
actual <- viz_data$condition
predicted <- viz_data$predicted_condition

conf_mat <- table(Actual = actual, Predicted = predicted)
conf_mat_prop <- prop.table(conf_mat, margin = 1)

# Convert to data frame for plotting
conf_df <- as.data.frame(conf_mat_prop)

# Create heatmap
p_conf <- ggplot(conf_df, aes(x = Predicted, y = Actual, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = sprintf("%.2f", Freq)), color = "white", size = 4) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                       midpoint = 0.5, limits = c(0, 1)) +
  theme_minimal() +
  labs(title = "Confusion Matrix (Normalized)",
       x = "Predicted", y = "Actual",
       fill = "Proportion") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p_conf)
```

## Prediction Confidence

```{r confidence_viz}
# Confidence distribution
p_conf_dist <- ggplot(meta_data, aes(x = prediction_confidence)) +
  geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Prediction Confidence Distribution",
       x = "Confidence Score", y = "Count") +
  geom_vline(xintercept = mean(meta_data$prediction_confidence),
             color = "red", linetype = "dashed", size = 1)

print(p_conf_dist)

# Confidence by condition
p_conf_cond <- ggplot(meta_data, aes(x = condition, y = prediction_confidence,
                                     fill = condition)) +
  geom_violin(alpha = 0.7) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "Confidence by Condition",
       x = "Condition", y = "Confidence Score") +
  scale_fill_brewer(palette = "Set1") +
  theme(legend.position = "none")

print(p_conf_cond)
```

# Using plot_scCulture Function

The package provides the `plot_scCulture` function for automated visualization:

```{r plot_scculture, eval=FALSE}
# Example of using plot_scCulture with analysis results
# This requires results from the scCulture() function

# results <- scCulture(
#   tenx_data_dir = "path/to/data",
#   input_type = "10x",
#   output_dir = "./results",
#   mode = "build"
# )
#
# # Create visualization
# p <- plot_scCulture(results)
# print(p)
```

# Custom Visualization Functions

## Creating Publication-Ready Figures

```{r custom_theme}
# Define custom theme for consistency
theme_publication <- function(base_size = 11) {
  theme_minimal(base_size = base_size) +
    theme(
      plot.title = element_text(size = base_size * 1.2, face = "bold", hjust = 0.5),
      axis.title = element_text(size = base_size * 1.1),
      axis.text = element_text(size = base_size * 0.9),
      legend.title = element_text(size = base_size * 1.1, face = "bold"),
      legend.text = element_text(size = base_size),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(color = "gray80", fill = NA, size = 0.5)
    )
}

# Apply custom theme
p_custom <- ggplot(meta_data, aes(x = UMAP_1, y = UMAP_2, color = condition)) +
  geom_point(size = 2, alpha = 0.7) +
  labs(title = "Publication-Ready UMAP",
       x = "UMAP 1", y = "UMAP 2",
       color = "Condition") +
  scale_color_brewer(palette = "Set1") +
  theme_publication()

print(p_custom)
```

## Saving Figures

```{r save_figures, eval=FALSE}
# Save figures in publication quality
# ggsave("umap_conditions.pdf", p_condition, width = 8, height = 6, dpi = 300)
# ggsave("confusion_matrix.png", p_conf, width = 8, height = 6, dpi = 300)
```

# Tips for Effective Visualization

1. **Color Selection**: Use colorblind-friendly palettes (e.g., Set1, Set2 from RColorBrewer)
2. **Clarity**: Avoid overcrowding plots; use faceting for multiple comparisons
3. **Consistency**: Maintain consistent color schemes across related plots
4. **Accessibility**: Include shape or pattern variations in addition to colors
5. **Export Quality**: Save at appropriate resolution (300 dpi for print, 72-150 for web)

# Session Information

```{r session_info}
sessionInfo()
```
